# pygls.protocol.json_rpc

**Module:** `pygls.protocol.json_rpc`

No module documentation available.

## Classes

### JsonRPCNotification

A class that represents a generic json rpc notification message.
Used as a fallback for unknown types.

**Methods:**

- `__init__(self, method: 'str', jsonrpc: 'str', params: 'Any') -> None`: Method generated by attrs for class JsonRPCNotification.

### JsonRPCProtocol

Json RPC protocol implementation

Specification of the protocol can be found here:
    https://www.jsonrpc.org/specification

This class provides bidirectional communication which is needed for LSP.

**Methods:**

- `__init__(self, server: 'JsonRPCServer', converter: 'Converter')`: Initialize self.  See help(type(self)) for accurate signature.
- `get_message_type(self, method: 'str') -> 'Type[Any] | None'`: Return the type definition of the message associated with the given method.
- `get_result_type(self, method: 'str') -> 'Type[Any] | None'`: Return the type definition of the result associated with the given method.
- `handle_message(self, message: 'RPCMessage')`: Delegates message to handlers depending on message type.
- `notify(self, method: 'str', params: 'Any | None' = None)`: Send a JSON-RPC notification.
- `send_request(self, method: 'str', params: 'Any | None' = None, callback: 'Callable[[Any], None] | None' = None, msg_id: 'MsgId | None' = None) -> 'Future[Any]'`: Send a JSON-RPC request
- `send_request_async(self, method: 'str', params: 'Any | None' = None, msg_id: 'MsgId | None' = None)`: Send a JSON-RPC request, asynchronously.
- `set_writer(self, writer: 'AsyncWriter | Writer', include_headers: 'bool' = True)`: Set the writer object to use when sending data
- `structure_message(self, data: 'dict[str, Any]')`: Function used to deserialize data recevied from the client.

### JsonRPCRequestMessage

A class that represents a generic json rpc request message.
Used as a fallback for unknown types.

**Methods:**

- `__init__(self, id: 'MsgId', method: 'str', jsonrpc: 'str', params: 'Any') -> None`: Method generated by attrs for class JsonRPCRequestMessage.

### JsonRPCResponseMessage

A class that represents a generic json rpc response message.
Used as a fallback for unknown types.

**Methods:**

- `__init__(self, id: 'MsgId', jsonrpc: 'str', result: 'Any') -> None`: Method generated by attrs for class JsonRPCResponseMessage.

### RPCError

Base class for protocol classes.

Protocol classes are defined as::

    class Proto(Protocol):
        def meth(self) -> int:
            ...

Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing).

For example::

    class C:
        def meth(self) -> int:
            return 0

    def func(x: Proto) -> int:
        return x.meth()

    func(C())  # Passes static type check

See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::

    class GenProto[T](Protocol):
        def meth(self) -> T:
            ...

**Methods:**

- `__init__(self, *args, **kwargs)`

### RPCNotification

Base class for protocol classes.

Protocol classes are defined as::

    class Proto(Protocol):
        def meth(self) -> int:
            ...

Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing).

For example::

    class C:
        def meth(self) -> int:
            return 0

    def func(x: Proto) -> int:
        return x.meth()

    func(C())  # Passes static type check

See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::

    class GenProto[T](Protocol):
        def meth(self) -> T:
            ...

**Methods:**

- `__init__(self, *args, **kwargs)`

### RPCRequest

Base class for protocol classes.

Protocol classes are defined as::

    class Proto(Protocol):
        def meth(self) -> int:
            ...

Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing).

For example::

    class C:
        def meth(self) -> int:
            return 0

    def func(x: Proto) -> int:
        return x.meth()

    func(C())  # Passes static type check

See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::

    class GenProto[T](Protocol):
        def meth(self) -> T:
            ...

**Methods:**

- `__init__(self, *args, **kwargs)`

### RPCResponse

Base class for protocol classes.

Protocol classes are defined as::

    class Proto(Protocol):
        def meth(self) -> int:
            ...

Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing).

For example::

    class C:
        def meth(self) -> int:
            return 0

    def func(x: Proto) -> int:
        return x.meth()

    func(C())  # Passes static type check

See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::

    class GenProto[T](Protocol):
        def meth(self) -> T:
            ...

**Methods:**

- `__init__(self, *args, **kwargs)`

